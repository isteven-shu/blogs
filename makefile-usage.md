# Rule (target, prerequisites, recipe)

A *rule* tells *make* two things:
- when the *target*s are out of date, and
- how to update them when necessary.

A simple makefile consists of “rules” with the following shape:
```
target … : prerequisites …
        recipe
        …
        …
```
## target
A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as `clean` (see [Phony targets](https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html#Phony-Targets)).
### How to decide whether a target is out of date:
It is out of date if it does not exist, or if any of the *prerequisite*s is more recent than it.
### How to update the file target:
Run the *recipe*.
### Phony Targets
A phony target is one that is **not** really *the name of a file* ; rather it is just a *name for a recipe* to be executed when you make an explicit request.
#### Usage
There are two reasons to use a phony target: 
- To avoid a conflict with a file of the same name
   如果存在与clean同名的文件，make clean时由于clean没有prerequisite，因此clean会被判定为没有outdated，所以clean的recipe永远不会被执行;
- To improve performance
   make的执行程序不会试图寻找clean的隐含规则。
#### Note
1. A phony target should not be a prerequisite of a real **target file**; if it is, its recipe will be run every time make goes to update that file. As long as a phony target is never a prerequisite of a real target, the phony target recipe will be executed only when the phony target is a specified goal.
2. Phony targets can have prerequisites. When one directory contains multiple programs, it is most convenient to describe all of the programs in one makefile ./Makefile. Since the target remade by default will be the first one in the makefile, it is common to make this a phony target named ‘all’ and give it, as prerequisites, all the individual programs. For example:
   ```
   all : prog1 prog2 prog3
   .PHONY : all
   prog1 : prog1.o utils.o
        cc -o prog1 prog1.o utils.o
   prog2 : prog2.o
        cc -o prog2 prog2.o
   prog3 : prog3.o sort.o utils.o
        cc -o prog3 prog3.o sort.o utils.o
   ```

   Now you can say just ‘make’ to remake all three programs, or specify as arguments the ones to remake (as in ‘make prog1 prog3’). Phoniness is not inherited: the prerequisites of a phony target are not themselves phony, unless explicitly declared to be so.

3. When one phony target is a prerequisite of another, it serves as a subroutine of the other. For example, here ‘make cleanall’ will delete the object files, the difference files, and the file program:
   ```
   .PHONY: cleanall cleanobj cleandiff
   cleanall : cleanobj cleandiff
        rm program
   cleanobj :
        rm *.o
   cleandiff :
        rm *.diff
   ```
## prerequisite
A prerequisite is a file that is used as input to create the target. A target often depends on several files.
## Recipe
A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line.
Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character (see [Special Variables](https://www.gnu.org/software/make/manual/html_node/Special-Variables.html#Special-Variables)).
- Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. 
- However, the rule that specifies a recipe for the target need not have prerequisites. For example, the rule containing the delete command associated with the target ‘clean’ does not have prerequisites.
- After each shell invocation returns, *make* looks at its exit status. If the shell completed successfully (the exit status is zero), the next line in the recipe is executed in a new shell; after the last line is finished, the rule is finished.
   - If there is an error (the exit status is nonzero), make gives up on the current rule, and perhaps on all rules.
   - Sometimes the failure of a certain recipe line does not indicate a problem. For example, you may use the mkdir command to ensure that a directory exists. If the directory already exists, mkdir will report an error, but you probably want make to continue regardless.
   To ignore errors in a recipe line, write a ‘-’ at the beginning of the line’s text (after the initial tab). The ‘-’ is discarded before the line is passed to the shell for execution.
# Goal of make
The goals are the targets that make should strive **ultimately** to update. Other targets are updated as well **if** they appear as prerequisites of goals, or prerequisites of prerequisites of goals, etc.
By default, the goal is the first target in the makefile (not counting targets that start with a period). Therefore, makefiles are usually written so that the first target is for compiling the entire program or programs they describe. If the first rule in the makefile has several targets, only the first target in the rule becomes the default goal, not the whole list. You can manage the selection of the default goal from within your makefile using the .DEFAULT_GOAL variable (see [Other Special Variables](https://www.gnu.org/software/make/manual/html_node/Special-Variables.html#Special-Variables)).
# Variable
## Definition
A variable is a name defined in a makefile to represent a string of text, called the variable’s value.

Leading whitespace characters are discarded while trailing space characters are not stripped from variable values.

There are two ways that a variable in GNU make can have a value; we call them the two flavors of variables. The two flavors are distinguished in how they are defined and in what they do when expanded.
- Recursively expanded variable
   - Definition: defined by lines using `=`
   - Expansion:
   If it contains references to other variables, these references are expanded whenever this variable is substituted (in the course of expanding some other string). When this happens, it is called recursive expansion.
- Simply expanded variables
   - Definition: defined by lines using `:=` or `::=`
   - Expansion
   The value of a simply expanded variable is scanned once and for all.
## Reference
To substitute a variable’s value, write a dollar sign followed by the name of the variable in parentheses or braces: either `$(foo)` or `${foo}` is a valid reference to the variable `foo`.
A dollar sign followed by a character other than a dollar sign, open-parenthesis or open-brace treats that single character as the variable name. Thus, you could reference the variable x with `$x`. However, this practice can lead to confusion (e.g., `$foo` refers to the variable `f` followed by the string `oo`) so we recommend using parentheses or braces around all variables, even single-letter variables.
